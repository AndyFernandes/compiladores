PARSER_BEGIN(Parser)

public class Parser{
    public static void main(String[] args) {
        try {
            new Parser(new java.io.FileInputStream(args[0])).Goal();                
            System.out.println("Syntax is okay");
        } catch (Throwable e) {
            // Catching Throwable is ugly but JavaCC throws Error objects!
            System.out.println("Syntax check failed: " + e.getMessage());
        }         
    }
}

PARSER_END(Parser)

TOKEN: {        < PUBLIC : "public" >{System.out.print("PUBLIC ");} 
        |       < CLASS : "class">  {System.out.print("CLASS ");} 
        |       < STATIC : "static" > {System.out.print("STATIC ");} 
        |       < VOID : "void" > {System.out.print("VOID ");} 
        |       < MAIN : "main" > {System.out.print("MAIN ");} 
        
        |       < RETURN : "return" > {System.out.print("RETURN ");} 
        |       < EXTENDS : "extends" > {System.out.print("EXTENDS ");} 
        |       < NEW : "new" > {System.out.print("NEW ");} 
        |       < PRINT : "System.out.println"> {System.out.print("PRINT ");} 
        |       < IF : "if" > {System.out.print("IF ");} 
        |       < ELSE : "else" > {System.out.print("ELSE ");} 
        |       < LENGTH : "length" > {System.out.print("LENGTH");} 
        |       < WHILE : "while" > {System.out.print("WHILE ");} 
        
        |       < STRING : "String" > {System.out.print("STRING ");} 
        |       < INT : "int" > {System.out.print("INT ");} 
        |       < BOOLEAN : "boolean" > {System.out.print("BOOLEAN ");} 
        
        |       < TRUE : "true" > {System.out.print("TRUE ");} 
        |       < FALSE : "false" > {System.out.print("FALSE ");} 
        |       < THIS : "this" > {System.out.print("THIS ");} 
   
        |       < #DIGIT: ["0"-"9"]> 
        |       < #LETTER: ["A"-"Z"]|["a"-"z"]>
        |       < #INTEGER: (<DIGIT>)+ >
        |       < #REAL: ((<DIGIT>)+ "." (<DIGIT>)*) | ((<DIGIT>)* "." (<DIGIT>)+) >
        |       < IDENTIFIER: <LETTER> (<LETTER> | <DIGIT> | "_")*> {System.out.print("IDENTIFIER{"+matchedToken.image+"} ");} 
        |       < INTEGER_LITERAL: (["a"-"z"] (["a"-"z"] | ["0"-"9"])*) | ((["0"-"9"])+) | (<REAL>) >  {System.out.print("INTEGER_LITERAL{"+matchedToken.image+"} ");}  
                
        |       < LPAREN: "("> {System.out.print("LPAREN ");} 
        |       < RPAREN: ")"> {System.out.print("RPAREN ");} 
        |       < LCOLCH: "["> {System.out.print("LCOLCH ");} 
        |       < RCOLCH: "]"> {System.out.print("RCOLCH ");} 
        |       < LBRACE: "{"> {System.out.print("LBRACE ");} 
        |       < RBRACE: "}"> {System.out.print("RBRACE ");} 
        |       < RBRACE_INTERROG: ")?"> {System.out.print("RBRACE_INTERROG ");} 
        |       < SEMI_COMMA: ";"> {System.out.print("SEMI_COMMA ");} 
        |       < DOT: "." > {System.out.print("DOT ");} 
        |       < BANG: "!" > {System.out.print("BANG ");} 
        |       < COMMA: "," > {System.out.print("COMMA ");} 
      
        |       < EQUAL: "="> {System.out.print("EQUAL ");} 
        |       < AND: "&&"> {System.out.print("AND ");} 
        |       < LESS_THEN: "<"> {System.out.print("LESS_THEN ");} 
        |       < BIGGER_THEN: ">"> {System.out.print("BIGGER_THEN ");} 
        |       < PLUS : "+" > {System.out.print("PLUS ");} 
        |       < MINUS : "-"> {System.out.print("MINUS ");} 
        |       < STAR: "*"> {System.out.print("STAR ");} 
}
    
SKIP : {        <"--"(["a"-"z"])*("\n" | "\r" | "\r\n")>
        |       <"/*" (~[])* "*/"> 
        |       <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")> 
        |       " " 
        |       "\t" 
        |       "\n"
        |       "\r"
}

Program Goal(): {}{
    Main main;
    ClassDeclaration class_decl;
    ClassList class_list;
    main = MainClass() (class_decl = (ClassDeclaration() {class_list.addElement(class_decl);})* <EOF>
    {return new Program(main, class_list);}
}

MainClass MainClass(): {}{
    Identifier id1;
    Identifier id2;
    Statement statement;

    <CLASS> id1 = Identifier() <LBRACE> <PUBLIC> <STATIC> <VOID> <MAIN> <LPAREN> <STRING> <LCOLCH> <RCOLCH> id2 = Identifier() <RPAREN> <LBRACE> statement = Statement() <RBRACE> <RBRACE>
    {return new Main(id1, id2, statement)}
}

ClassDeclaration ClassDeclaration(): {}{
    Identifier id1;
    Identifier id2;
    Va
    <CLASS> Identifier() (<EXTENDS> Identifier())? <LBRACE> (LOOKAHEAD(2) VarDeclaration())* (MethodDeclaration())* <RBRACE>
}

VarDeclaration VarDeclaration(): {}{
    Type() Identifier () <SEMI_COMMA>
}

MethodDeclaration MethodDeclaration(): {}{
    <PUBLIC> Type() Identifier() <LPAREN> (Type() Identifier() (<COMMA> Type() Identifier())*)? <RPAREN> <LBRACE> ( LOOKAHEAD(2) VarDeclaration())* (Statement())* <RETURN> Expression() <SEMI_COMMA> <RBRACE>
}

Type Type(): {}{

    LOOKAHEAD(2)
    <INT> <LCOLCH><RCOLCH>
    | <INT>
    | Identifier()
    | <BOOLEAN>
}

Statement Statement(): {}{
    <LBRACE> (Statement())* <RBRACE>
    | <IF> <LPAREN> Expression() <RPAREN> Statement() <ELSE> Statement()
    | <WHILE> <LPAREN> Expression() <RPAREN> Statement()
    | <PRINT> <LPAREN> Expression() <RPAREN> <SEMI_COMMA>
    
    | LOOKAHEAD(2) 
    Identifier() <EQUAL> Expression() <SEMI_COMMA>
    | Identifier() <LCOLCH> Expression() <RCOLCH> <EQUAL> Expression() <SEMI_COMMA>

}

Expression Exp(Expression exp): {

     Expression exp2;
    And ad;
    Less_then less;
    Plus plus;
    Minus minus;
    Star star;
    ArrayExpression arrayExpression;
    Length len;
    Identifier id;
    ExpressionList expList; 
    BigExpression bigExpression;
    
}{ 
   
    <AND> 
    exp2 = Expression() 
    {ad = new Plus(exp, exp2);}
    {return Expression(ad)}  
    
    | <LESS_THEN> 
    exp2 = Expression() 
    {less = new Less_then(exp, exp2);}
    {return Expression(less)}
    
    | <PLUS> exp2 = Expression() 
    {plus = new Plus(exp, exp2);}
    {return Expression(plus)}
    
    | <MINUS> exp2 = Expression()
    {minus =  new Minus(exp, exp2);}
    {return Expression(minus)}
    
    | <STAR> exp2 = Expression() 
    {star = new Star(exp, exp2);}
    {return Expression(star)}
	
    | <LCOLCH> 
    exp2 = Expression() 
    <RCOLCH> 
    {arrayExpression = new ArrayExpression(exp, exp2);}
    {return Expression(arrayExpression)}
	
    | LOOKAHEAD(3) <DOT> 
    <LENGTH> 
    {len = new Length(exp);}
    {return Expression(len)}
	
    | <DOT> 
    {id = Identifier();} 
    <LPAREN>
    {expList = ExpressionList();} 
    <RPAREN> 
    {bigExpression = new BigExpression(e1, id, expList);}
	{return Expression(bigExpression);}
    
    | {return exp;}	
}

Expression Expression(): {

    INTEGER_LITERAL int_li;
    True t;
    False f;
    Identifier id;
    This thi;
    Expression exp;
    Identifier id2;
    Expression exp2;
    NewArray newArray;
    NewObject newObj;
    Not no;
    Expression exp3, exp4;

}{

	<INTEGER_LITERAL> 
    {int_li = new INTEGER_LITERAL(Integer.parseInt(token.image));} 
    { return Exp(int_li; )}
	
    | <TRUE>
    {t = new True();}
    { return Exp(t); }

	| <FALSE> 
    {f = new False();}
    { return Exp(f); }

	| Identifier() 
    {id = new Identifier();}
    { return Exp(id); }

	| <THIS> 
    Exp() 
    {thi = new This(); }
    {return Exp(thi)}

	| LOOKAHEAD(2) <NEW> <INT> <LCOLCH>
    exp = Expression() 
    <RCOLCH>
     {newArray = new NewArray(exp);}
    {return Exp(newArray)}

	| <NEW> 
    {id2 = new Identifier();} 
    <LPAREN> <RPAREN> 
    {newObj = new NewObject(id2);}
	{return Exp(newObj)}

    | <BANG> 
    exp3 = Expression()
    {no = new Not(exp3);}
    {return Exp(exp3);}

	| <LPAREN> 
    exp4 = Expression() 
    <RPAREN> 
    {return Exp(exp4); }
}

Identifier Identifier(): {}{
	<IDENTIFIER>
}

