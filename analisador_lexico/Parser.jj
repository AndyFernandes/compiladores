PARSER_BEGIN(Parser)

public class Parser{
    public static void main(String[] args) {
        try {
            new Parser(new java.io.FileInputStream(args[0])).Goal();                
            //System.out.println(args[0]);
            System.out.println("Syntax is okay");
        } catch (Throwable e) {
            // Catching Throwable is ugly but JavaCC throws Error objects!
            System.out.println("Syntax check failed: " + e.getMessage());
        } /*  catch (FileNotFoundException e) {
            System.out.println("File not Found: " + args[0]);
        } catch (ParseException e){
            System.out.println("Erro no parse: " e);
        } catch(TokenMsgError e){
            System.out.println("Erro na leitura do Token:" + e);
        } */        
    }
}

PARSER_END(Parser)

TOKEN: {        < PUBLIC : "public" >{System.out.print("PUBLIC ");} 
        |       < CLASS : "class">  {System.out.print("CLASS ");} 
        |       < STATIC : "static" > {System.out.print("STATIC ");} 
        |       < VOID : "void" > {System.out.print("VOID ");} 
        |       < MAIN : "main" > {System.out.print("MAIN ");} 
        
        |       < RETURN : "return" > {System.out.print("RETURN ");} 
        |       < EXTENDS : "extends" > {System.out.print("EXTENDS ");} 
        |       < NEW : "new" > {System.out.print("NEW ");} 
        |       < PRINT : "System.out.println"> {System.out.print("PRINT ");} 
        |       < IF : "if" > {System.out.print("IF ");} 
        |       < ELSE : "else" > {System.out.print("ELSE ");} 
        |       < LENGTH : "length" > {System.out.print("LENGTH");} 
        |       < WHILE : "while" > {System.out.print("WHILE ");} 
        
        |       < STRING : "String" > {System.out.print("STRING ");} 
        |       < INT : "int" > {System.out.print("INT ");} 
        |       < BOOLEAN : "boolean" > {System.out.print("BOOLEAN ");} 
        
        |       < TRUE : "true" > {System.out.print("TRUE ");} 
        |       < FALSE : "false" > {System.out.print("FALSE ");} 
        |       < THIS : "this" > {System.out.print("THIS ");} 
   
        // Verificar se a definição dessas e.r. funcionam e se são suficientes
        |       < #DIGIT: ["0"-"9"]> 
        |       < #LETTER: ["A"-"Z"]|["a"-"z"]>
        |       < #INTEGER: (<DIGIT>)+ >
        |       < #REAL: ((<DIGIT>)+ "." (<DIGIT>)*) | ((<DIGIT>)* "." (<DIGIT>)+) >
        |       < IDENTIFIER: <LETTER> (<LETTER> | <DIGIT> | "_")*> {System.out.print("IDENTIFIER{"+matchedToken.image+"} ");} 
        |       < INTEGER_LITERAL: (["a"-"z"] (["a"-"z"] | ["0"-"9"])*) | ((["0"-"9"])+) | (<REAL>) >  {System.out.print("INTEGER_LITERAL{"+matchedToken.image+"} ");}  
                
        |       < LPAREN: "("> {System.out.print("LPAREN ");} 
        |       < RPAREN: ")"> {System.out.print("RPAREN ");} 
        |       < LCOLCH: "["> {System.out.print("LCOLCH ");} 
        |       < RCOLCH: "]"> {System.out.print("RCOLCH ");} 
        |       < LBRACE: "{"> {System.out.print("LBRACE ");} 
        |       < RBRACE: "}"> {System.out.print("RBRACE ");} 
        |       < RBRACE_INTERROG: ")?"> {System.out.print("RBRACE_INTERROG ");} 
        |       < SEMI_COMMA: ";"> {System.out.print("SEMI_COMMA ");} 
        |       < DOT: "." > {System.out.print("DOT ");} 
        |       < BANG: "!" > {System.out.print("BANG ");} 
        |       < COMMA: "," > {System.out.print("COMMA ");} 
      
        |       < EQUAL: "="> {System.out.print("EQUAL ");} 
        |       < AND: "&&"> {System.out.print("AND ");} 
        |       < LESS_THEN: "<"> {System.out.print("LESS_THEN ");} 
        |       < BIGGER_THEN: ">"> {System.out.print("BIGGER_THEN ");} 
        |       < PLUS : "+" > {System.out.print("PLUS ");} 
        |       < MINUS : "-"> {System.out.print("MINUS ");} 
        |       < STAR: "*"> {System.out.print("STAR ");} 
}
    
SKIP : {        <"--"(["a"-"z"])*("\n" | "\r" | "\r\n")>
        |       <"/*" (~[])* "*/"> // Verificar se a definição dessas e.r. funcionam e se são suficientes
        |       <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")> // Verificar se a definição dessas e.r. funcionam e se são suficientes
        |       " " 
        |       "\t" 
        |       "\n"
        |       "\r"
}

// void init(): {} {
//         (
//             <PUBLIC> | <CLASS> | <STATIC> | <VOID> | <MAIN> | <RETURN> | <EXTENDS> | <NEW> | <PRINT> | <IF> | <ELSE> | <LENGTH> | <WHILE> 
//         |   <STRING> | <INT> | <BOOLEAN> | <TRUE> | <FALSE> | <THIS> |  <IDENTIFIER> | <INTEGER_LITERAL> 
//         |   <LPAREN> | <RPAREN> | <LCOLCH> | <RCOLCH> | <LBRACE> | <RBRACE> | <RBRACE_INTERROG> | <SEMI_COMMA> | <DOT> 
//         |   <BANG> | <COMMA> | <EQUAL> | <AND> | <LESS_THEN> | <BIGGER_THEN> | <PLUS> | <MINUS> | <STAR> 
        
//         )* <EOF>
// }

void Goal(): {}{
	MainClass() (ClassDeclaration())* <EOF>
}

void MainClass(): {}{
    <CLASS> Identifier() <LBRACE> <PUBLIC> <STATIC> <VOID> <MAIN> <LPAREN> <STRING> <LCOLCH> <RCOLCH> Identifier() <RPAREN> <LBRACE> Statement() <RBRACE> <RBRACE>
}

void ClassDeclaration(): {}{
    <CLASS> Identifier() (<EXTENDS> Identifier())? <LBRACE> (LOOKAHEAD(2) VarDeclaration())* (MethodDeclaration())* <RBRACE>
}

void VarDeclaration(): {}{
    Type() Identifier () <SEMI_COMMA>
}

void MethodDeclaration(): {}{
    <PUBLIC> Type() Identifier() <LPAREN> (Type() Identifier() (<COMMA> Type() Identifier())*)? <RPAREN> <LBRACE> ( LOOKAHEAD(2) VarDeclaration())* (Statement())* <RETURN> Expression() <SEMI_COMMA> <RBRACE>
}

void Type(): {}{

    // ver como funciona esse lookahead http://cs.lmu.edu/~ray/notes/javacc/
    LOOKAHEAD(2)
    <INT> <LCOLCH><RCOLCH>
    | <INT>
    | Identifier()
    | <BOOLEAN>
}

void Statement(): {}{
    <LBRACE> (Statement())* <RBRACE>
    | <IF> <LPAREN> Expression() <RPAREN> Statement() <ELSE> Statement()
    | <WHILE> <LPAREN> Expression() <RPAREN> Statement()
    | <PRINT> <LPAREN> Expression() <RPAREN> <SEMI_COMMA>
    
    | LOOKAHEAD(2) 
    Identifier() <EQUAL> Expression() <SEMI_COMMA>
    | Identifier() <LCOLCH> Expression() <RCOLCH> <EQUAL> Expression() <SEMI_COMMA>

}

void Exp(): {}{
	(<AND> | <LESS_THEN> | <PLUS> | <MINUS> | <STAR> ) Expression() Exp()
	| <LCOLCH> Expression() <RCOLCH> Exp()
	| LOOKAHEAD(3) <DOT> <LENGTH> Exp()
	| <DOT> Identifier() <LPAREN> (Expression()(<COMMA>Expression())*)? <RPAREN> Exp()
	| {}//conferir se a derivação do vazio é assim	
}

void Expression(): {}{
	<INTEGER_LITERAL> Exp()
	| <TRUE> Exp()
	| <FALSE> Exp()
	| Identifier() Exp()
	| <THIS> Exp()
	| LOOKAHEAD(2) <NEW> <INT> <LCOLCH> Expression() <RCOLCH> Exp()
	| <NEW> Identifier() <LPAREN> <RPAREN> Exp()
	| <BANG> Expression() Exp() 
	| <LPAREN> Expression() <RPAREN> Exp()
}

void Identifier(): {}{
	<IDENTIFIER>
}

